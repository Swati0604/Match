{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.withManager = withManager;\nexports.ScrollManager = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _timedMutationObserver = _interopRequireDefault(require(\"./timedMutationObserver\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nconst debug = require('debug')('ScrollManager');\n\nconst ManagerContext = _react.default.createContext();\n\nconst defaultTimeout = 3000;\n\nclass ScrollManager extends _react.default.Component {\n  constructor(props) {\n    super(props);\n    const history = props.history,\n          _props$sessionKey = props.sessionKey,\n          sessionKey = _props$sessionKey === void 0 ? 'ScrollManager' : _props$sessionKey,\n          _props$timeout = props.timeout,\n          timeout = _props$timeout === void 0 ? defaultTimeout : _props$timeout;\n\n    if ('scrollRestoration' in window.history) {\n      this._originalScrollRestoration = window.history.scrollRestoration;\n      window.history.scrollRestoration = 'manual';\n    } // load positions and associated tracking data from session state\n\n\n    try {\n      const data = sessionStorage.getItem(sessionKey);\n      this._session = JSON.parse(data || '{}');\n    } catch (e) {\n      debug('Error reading session storage:', e.message);\n      this._session = {};\n    }\n\n    this._positions = this._session.positions || (this._session.positions = {});\n    this._locations = this._session.locations || (this._session.locations = []);\n    this._historyStart = history.length - this._locations.length;\n    const initialKey = 'initial';\n    this._locationKey = this._session.locationKey || initialKey; // initialize emphemeral state of scrollable nodes\n\n    this._scrollableNodes = {};\n    this._deferredNodes = {};\n    window.addEventListener('beforeunload', () => {\n      // write everything back to session state on unload\n      this._savePositions();\n\n      this._session.locationKey = this._locationKey;\n\n      try {\n        sessionStorage.setItem(sessionKey, JSON.stringify(this._session));\n      } catch (e) {// session state full or unavailable\n      }\n    });\n    this._unlisten = history.listen((location, action) => {\n      this._savePositions(); // cancel any pending hash scroller\n\n\n      if (this._hashScroller) {\n        this._hashScroller.cancel();\n\n        this._hashScroller = null;\n      } // clean up positions no longer in history to avoid leaking memory\n      // (including last history element if action is PUSH or REPLACE)\n\n\n      const locationCount = Math.max(0, history.length - this._historyStart - (action !== 'POP' ? 1 : 0));\n\n      while (this._locations.length > locationCount) {\n        const key = this._locations.pop();\n\n        delete this._positions[key];\n      }\n\n      const key = location.key || initialKey;\n\n      if (action !== 'POP') {\n        // track the new location key in our array of locations\n        this._locations.push(key);\n\n        this._historyStart = history.length - this._locations.length; // check for hash links that need deferral of scrolling into view\n\n        if (typeof location.hash === 'string' && location.hash.length > 1) {\n          const elementId = location.hash.substring(1);\n          this._hashScroller = (0, _timedMutationObserver.default)(() => {\n            const element = document.getElementById(elementId);\n\n            if (element) {\n              debug(\"Scrolling element \".concat(elementId, \" into view\"));\n              element.scrollIntoView();\n              return true;\n            }\n\n            return false;\n          }, timeout);\n\n          this._hashScroller.catch(e => {\n            if (!e.cancelled) {\n              debug(\"Timeout scrolling hash element \".concat(elementId, \" into view\"));\n            }\n          });\n        }\n      } // set current location key for saving position on next history change\n\n\n      this._locationKey = key;\n    });\n  }\n\n  componentWillUnmount() {\n    if (this._unlisten) {\n      this._unlisten();\n    }\n\n    if (this._originalScrollRestoration) {\n      window.history.scrollRestoration = this._originalScrollRestoration;\n    }\n  }\n\n  render() {\n    return /*#__PURE__*/_react.default.createElement(ManagerContext.Provider, {\n      value: this\n    }, this.props.children);\n  }\n\n  _registerElement(scrollKey, node) {\n    this._scrollableNodes[scrollKey] = node;\n\n    this._restoreNode(scrollKey);\n  }\n\n  _unregisterElement(scrollKey) {\n    delete this._scrollableNodes[scrollKey];\n  }\n\n  _savePositions() {\n    // use pageXOffset instead of scrollX for IE compatibility\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollX#Notes\n    const _window = window,\n          scrollX = _window.pageXOffset,\n          scrollY = _window.pageYOffset;\n\n    this._savePosition('window', {\n      scrollX,\n      scrollY\n    });\n\n    for (const scrollKey in this._scrollableNodes) {\n      const node = this._scrollableNodes[scrollKey];\n      const scrollLeft = node.scrollLeft,\n            scrollTop = node.scrollTop;\n\n      this._savePosition(scrollKey, {\n        scrollLeft,\n        scrollTop\n      });\n    }\n  }\n\n  _savePosition(scrollKey, position) {\n    debug('save', this._locationKey, scrollKey, position);\n\n    if (!(scrollKey in this._deferredNodes)) {\n      let loc = this._positions[this._locationKey];\n\n      if (!loc) {\n        loc = this._positions[this._locationKey] = {};\n      }\n\n      loc[scrollKey] = position;\n    } else {\n      debug(\"Skipping save due to deferred scroll of \".concat(scrollKey));\n    }\n  }\n\n  _loadPosition(scrollKey) {\n    const loc = this._positions[this._locationKey];\n    return loc ? loc[scrollKey] || null : null;\n  }\n\n  _restoreNode(scrollKey) {\n    const position = this._loadPosition(scrollKey);\n\n    const _ref = position || {},\n          _ref$scrollLeft = _ref.scrollLeft,\n          scrollLeft = _ref$scrollLeft === void 0 ? 0 : _ref$scrollLeft,\n          _ref$scrollTop = _ref.scrollTop,\n          scrollTop = _ref$scrollTop === void 0 ? 0 : _ref$scrollTop;\n\n    debug('restore', this._locationKey, scrollKey, scrollLeft, scrollTop);\n\n    this._cancelDeferred(scrollKey);\n\n    const node = this._scrollableNodes[scrollKey];\n\n    const attemptScroll = () => {\n      node.scrollLeft = scrollLeft;\n      node.scrollTop = scrollTop;\n      return node.scrollLeft === scrollLeft && node.scrollTop === scrollTop;\n    };\n\n    if (!attemptScroll()) {\n      const failedScroll = () => {\n        debug(\"Could not scroll \".concat(scrollKey, \" to (\").concat(scrollLeft, \", \").concat(scrollTop, \")\") + \"; scroll size is (\".concat(node.scrollWidth, \", \").concat(node.scrollHeight, \")\"));\n      };\n\n      const _this$props$timeout = this.props.timeout,\n            timeout = _this$props$timeout === void 0 ? defaultTimeout : _this$props$timeout;\n\n      if (timeout) {\n        debug(\"Deferring scroll of \".concat(scrollKey, \" for up to \").concat(timeout, \" ms\"));\n        (this._deferredNodes[scrollKey] = (0, _timedMutationObserver.default)(attemptScroll, timeout, node)).then(() => delete this._deferredNodes[scrollKey]).catch(e => {\n          if (!e.cancelled) failedScroll();\n        });\n      } else {\n        failedScroll();\n      }\n    }\n  }\n\n  _restoreWindow() {\n    const scrollKey = 'window';\n\n    const position = this._loadPosition(scrollKey);\n\n    const _ref2 = position || {},\n          _ref2$scrollX = _ref2.scrollX,\n          scrollX = _ref2$scrollX === void 0 ? 0 : _ref2$scrollX,\n          _ref2$scrollY = _ref2.scrollY,\n          scrollY = _ref2$scrollY === void 0 ? 0 : _ref2$scrollY;\n\n    debug('restore', this._locationKey, scrollKey, scrollX, scrollY);\n\n    this._cancelDeferred(scrollKey);\n\n    const attemptScroll = () => {\n      window.scrollTo(scrollX, scrollY);\n      return window.pageXOffset === scrollX && window.pageYOffset === scrollY;\n    };\n\n    if (!attemptScroll()) {\n      const failedScroll = () => {\n        debug(\"Could not scroll \".concat(scrollKey, \" to (\").concat(scrollX, \", \").concat(scrollY, \")\") + \"; scroll size is (\".concat(document.body.scrollWidth, \", \").concat(document.body.scrollHeight, \")\"));\n      };\n\n      const _this$props$timeout2 = this.props.timeout,\n            timeout = _this$props$timeout2 === void 0 ? defaultTimeout : _this$props$timeout2;\n\n      if (timeout) {\n        debug(\"Deferring scroll of \".concat(scrollKey, \" for up to \").concat(timeout, \" ms\"));\n        (this._deferredNodes[scrollKey] = (0, _timedMutationObserver.default)(attemptScroll, timeout)).then(() => delete this._deferredNodes[scrollKey]).catch(e => {\n          if (!e.cancelled) failedScroll();\n        });\n      } else {\n        failedScroll();\n      }\n    }\n  }\n\n  _restoreInitial() {\n    if (!location.hash) {\n      this._restoreWindow();\n    }\n  }\n\n  _cancelDeferred(scrollKey) {\n    const deferred = this._deferredNodes[scrollKey];\n\n    if (deferred) {\n      debug(\"Cancelling deferred scroll of \".concat(scrollKey));\n      delete this._deferredNodes[scrollKey];\n      deferred.cancel();\n    }\n  }\n\n}\n\nexports.ScrollManager = ScrollManager;\nScrollManager.propTypes = {\n  history: _propTypes.default.object.isRequired,\n  sessionKey: _propTypes.default.string,\n  timeout: _propTypes.default.number,\n  children: _propTypes.default.node\n};\n\nfunction withManager(Component) {\n  return function ManagedComponent(props) {\n    return /*#__PURE__*/_react.default.createElement(ManagerContext.Consumer, null, manager => /*#__PURE__*/_react.default.createElement(Component, _extends({}, props, {\n      manager: manager\n    })));\n  };\n}","map":{"version":3,"sources":["/Users/swati/Desktop/DesignSunday/POSTS/posts/node_modules/react-scroll-manager/lib/ScrollManager.js"],"names":["Object","defineProperty","exports","value","withManager","ScrollManager","_react","_interopRequireDefault","require","_propTypes","_timedMutationObserver","obj","__esModule","default","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","debug","ManagerContext","createContext","defaultTimeout","Component","constructor","props","history","_props$sessionKey","sessionKey","_props$timeout","timeout","window","_originalScrollRestoration","scrollRestoration","data","sessionStorage","getItem","_session","JSON","parse","e","message","_positions","positions","_locations","locations","_historyStart","initialKey","_locationKey","locationKey","_scrollableNodes","_deferredNodes","addEventListener","_savePositions","setItem","stringify","_unlisten","listen","location","action","_hashScroller","cancel","locationCount","Math","max","pop","push","hash","elementId","substring","element","document","getElementById","concat","scrollIntoView","catch","cancelled","componentWillUnmount","render","createElement","Provider","children","_registerElement","scrollKey","node","_restoreNode","_unregisterElement","_window","scrollX","pageXOffset","scrollY","pageYOffset","_savePosition","scrollLeft","scrollTop","position","loc","_loadPosition","_ref","_ref$scrollLeft","_ref$scrollTop","_cancelDeferred","attemptScroll","failedScroll","scrollWidth","scrollHeight","_this$props$timeout","then","_restoreWindow","_ref2","_ref2$scrollX","_ref2$scrollY","scrollTo","body","_this$props$timeout2","_restoreInitial","deferred","propTypes","object","isRequired","string","number","ManagedComponent","Consumer","manager"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.withManager = withManager;\nexports.ScrollManager = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _timedMutationObserver = _interopRequireDefault(require(\"./timedMutationObserver\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nconst debug = require('debug')('ScrollManager');\n\nconst ManagerContext = _react.default.createContext();\n\nconst defaultTimeout = 3000;\n\nclass ScrollManager extends _react.default.Component {\n  constructor(props) {\n    super(props);\n    const history = props.history,\n          _props$sessionKey = props.sessionKey,\n          sessionKey = _props$sessionKey === void 0 ? 'ScrollManager' : _props$sessionKey,\n          _props$timeout = props.timeout,\n          timeout = _props$timeout === void 0 ? defaultTimeout : _props$timeout;\n\n    if ('scrollRestoration' in window.history) {\n      this._originalScrollRestoration = window.history.scrollRestoration;\n      window.history.scrollRestoration = 'manual';\n    } // load positions and associated tracking data from session state\n\n\n    try {\n      const data = sessionStorage.getItem(sessionKey);\n      this._session = JSON.parse(data || '{}');\n    } catch (e) {\n      debug('Error reading session storage:', e.message);\n      this._session = {};\n    }\n\n    this._positions = this._session.positions || (this._session.positions = {});\n    this._locations = this._session.locations || (this._session.locations = []);\n    this._historyStart = history.length - this._locations.length;\n    const initialKey = 'initial';\n    this._locationKey = this._session.locationKey || initialKey; // initialize emphemeral state of scrollable nodes\n\n    this._scrollableNodes = {};\n    this._deferredNodes = {};\n    window.addEventListener('beforeunload', () => {\n      // write everything back to session state on unload\n      this._savePositions();\n\n      this._session.locationKey = this._locationKey;\n\n      try {\n        sessionStorage.setItem(sessionKey, JSON.stringify(this._session));\n      } catch (e) {// session state full or unavailable\n      }\n    });\n    this._unlisten = history.listen((location, action) => {\n      this._savePositions(); // cancel any pending hash scroller\n\n\n      if (this._hashScroller) {\n        this._hashScroller.cancel();\n\n        this._hashScroller = null;\n      } // clean up positions no longer in history to avoid leaking memory\n      // (including last history element if action is PUSH or REPLACE)\n\n\n      const locationCount = Math.max(0, history.length - this._historyStart - (action !== 'POP' ? 1 : 0));\n\n      while (this._locations.length > locationCount) {\n        const key = this._locations.pop();\n\n        delete this._positions[key];\n      }\n\n      const key = location.key || initialKey;\n\n      if (action !== 'POP') {\n        // track the new location key in our array of locations\n        this._locations.push(key);\n\n        this._historyStart = history.length - this._locations.length; // check for hash links that need deferral of scrolling into view\n\n        if (typeof location.hash === 'string' && location.hash.length > 1) {\n          const elementId = location.hash.substring(1);\n          this._hashScroller = (0, _timedMutationObserver.default)(() => {\n            const element = document.getElementById(elementId);\n\n            if (element) {\n              debug(\"Scrolling element \".concat(elementId, \" into view\"));\n              element.scrollIntoView();\n              return true;\n            }\n\n            return false;\n          }, timeout);\n\n          this._hashScroller.catch(e => {\n            if (!e.cancelled) {\n              debug(\"Timeout scrolling hash element \".concat(elementId, \" into view\"));\n            }\n          });\n        }\n      } // set current location key for saving position on next history change\n\n\n      this._locationKey = key;\n    });\n  }\n\n  componentWillUnmount() {\n    if (this._unlisten) {\n      this._unlisten();\n    }\n\n    if (this._originalScrollRestoration) {\n      window.history.scrollRestoration = this._originalScrollRestoration;\n    }\n  }\n\n  render() {\n    return /*#__PURE__*/_react.default.createElement(ManagerContext.Provider, {\n      value: this\n    }, this.props.children);\n  }\n\n  _registerElement(scrollKey, node) {\n    this._scrollableNodes[scrollKey] = node;\n\n    this._restoreNode(scrollKey);\n  }\n\n  _unregisterElement(scrollKey) {\n    delete this._scrollableNodes[scrollKey];\n  }\n\n  _savePositions() {\n    // use pageXOffset instead of scrollX for IE compatibility\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollX#Notes\n    const _window = window,\n          scrollX = _window.pageXOffset,\n          scrollY = _window.pageYOffset;\n\n    this._savePosition('window', {\n      scrollX,\n      scrollY\n    });\n\n    for (const scrollKey in this._scrollableNodes) {\n      const node = this._scrollableNodes[scrollKey];\n      const scrollLeft = node.scrollLeft,\n            scrollTop = node.scrollTop;\n\n      this._savePosition(scrollKey, {\n        scrollLeft,\n        scrollTop\n      });\n    }\n  }\n\n  _savePosition(scrollKey, position) {\n    debug('save', this._locationKey, scrollKey, position);\n\n    if (!(scrollKey in this._deferredNodes)) {\n      let loc = this._positions[this._locationKey];\n\n      if (!loc) {\n        loc = this._positions[this._locationKey] = {};\n      }\n\n      loc[scrollKey] = position;\n    } else {\n      debug(\"Skipping save due to deferred scroll of \".concat(scrollKey));\n    }\n  }\n\n  _loadPosition(scrollKey) {\n    const loc = this._positions[this._locationKey];\n    return loc ? loc[scrollKey] || null : null;\n  }\n\n  _restoreNode(scrollKey) {\n    const position = this._loadPosition(scrollKey);\n\n    const _ref = position || {},\n          _ref$scrollLeft = _ref.scrollLeft,\n          scrollLeft = _ref$scrollLeft === void 0 ? 0 : _ref$scrollLeft,\n          _ref$scrollTop = _ref.scrollTop,\n          scrollTop = _ref$scrollTop === void 0 ? 0 : _ref$scrollTop;\n\n    debug('restore', this._locationKey, scrollKey, scrollLeft, scrollTop);\n\n    this._cancelDeferred(scrollKey);\n\n    const node = this._scrollableNodes[scrollKey];\n\n    const attemptScroll = () => {\n      node.scrollLeft = scrollLeft;\n      node.scrollTop = scrollTop;\n      return node.scrollLeft === scrollLeft && node.scrollTop === scrollTop;\n    };\n\n    if (!attemptScroll()) {\n      const failedScroll = () => {\n        debug(\"Could not scroll \".concat(scrollKey, \" to (\").concat(scrollLeft, \", \").concat(scrollTop, \")\") + \"; scroll size is (\".concat(node.scrollWidth, \", \").concat(node.scrollHeight, \")\"));\n      };\n\n      const _this$props$timeout = this.props.timeout,\n            timeout = _this$props$timeout === void 0 ? defaultTimeout : _this$props$timeout;\n\n      if (timeout) {\n        debug(\"Deferring scroll of \".concat(scrollKey, \" for up to \").concat(timeout, \" ms\"));\n        (this._deferredNodes[scrollKey] = (0, _timedMutationObserver.default)(attemptScroll, timeout, node)).then(() => delete this._deferredNodes[scrollKey]).catch(e => {\n          if (!e.cancelled) failedScroll();\n        });\n      } else {\n        failedScroll();\n      }\n    }\n  }\n\n  _restoreWindow() {\n    const scrollKey = 'window';\n\n    const position = this._loadPosition(scrollKey);\n\n    const _ref2 = position || {},\n          _ref2$scrollX = _ref2.scrollX,\n          scrollX = _ref2$scrollX === void 0 ? 0 : _ref2$scrollX,\n          _ref2$scrollY = _ref2.scrollY,\n          scrollY = _ref2$scrollY === void 0 ? 0 : _ref2$scrollY;\n\n    debug('restore', this._locationKey, scrollKey, scrollX, scrollY);\n\n    this._cancelDeferred(scrollKey);\n\n    const attemptScroll = () => {\n      window.scrollTo(scrollX, scrollY);\n      return window.pageXOffset === scrollX && window.pageYOffset === scrollY;\n    };\n\n    if (!attemptScroll()) {\n      const failedScroll = () => {\n        debug(\"Could not scroll \".concat(scrollKey, \" to (\").concat(scrollX, \", \").concat(scrollY, \")\") + \"; scroll size is (\".concat(document.body.scrollWidth, \", \").concat(document.body.scrollHeight, \")\"));\n      };\n\n      const _this$props$timeout2 = this.props.timeout,\n            timeout = _this$props$timeout2 === void 0 ? defaultTimeout : _this$props$timeout2;\n\n      if (timeout) {\n        debug(\"Deferring scroll of \".concat(scrollKey, \" for up to \").concat(timeout, \" ms\"));\n        (this._deferredNodes[scrollKey] = (0, _timedMutationObserver.default)(attemptScroll, timeout)).then(() => delete this._deferredNodes[scrollKey]).catch(e => {\n          if (!e.cancelled) failedScroll();\n        });\n      } else {\n        failedScroll();\n      }\n    }\n  }\n\n  _restoreInitial() {\n    if (!location.hash) {\n      this._restoreWindow();\n    }\n  }\n\n  _cancelDeferred(scrollKey) {\n    const deferred = this._deferredNodes[scrollKey];\n\n    if (deferred) {\n      debug(\"Cancelling deferred scroll of \".concat(scrollKey));\n      delete this._deferredNodes[scrollKey];\n      deferred.cancel();\n    }\n  }\n\n}\n\nexports.ScrollManager = ScrollManager;\nScrollManager.propTypes = {\n  history: _propTypes.default.object.isRequired,\n  sessionKey: _propTypes.default.string,\n  timeout: _propTypes.default.number,\n  children: _propTypes.default.node\n};\n\nfunction withManager(Component) {\n  return function ManagedComponent(props) {\n    return /*#__PURE__*/_react.default.createElement(ManagerContext.Consumer, null, manager => /*#__PURE__*/_react.default.createElement(Component, _extends({}, props, {\n      manager: manager\n    })));\n  };\n}"]},"metadata":{},"sourceType":"script"}